<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiment Tree Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        
        .container {
            display: flex;
            flex: 1;
            margin-top: 20px;
            min-height: 0; /* Required for Firefox */
        }
        
        #tree-container {
            flex: 1;
            border: 1px solid #ccc;
            padding: 10px;
            overflow: auto;
            min-height: 0; /* Required for Firefox */
        }
        
        #details-panel {
            flex: 1;
            border: 1px solid #ccc;
            padding: 20px;
            margin-left: 20px;
            overflow: auto;
            min-height: 0; /* Required for Firefox */
        }
        
        .node circle {
            fill: steelblue;
            stroke: #fff;
            stroke-width: 1.5px;
        }
        
        .node text {
            font-size: 10px;
        }
        
        .node.selected circle {
            fill: #ff5722;
        }
        
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
        
        .upload-area {
            margin-bottom: 20px;
            padding: 10px;
            border: 2px dashed #ccc;
            text-align: center;
        }
        
        .file-list {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .file-item {
            background: #f0f0f0;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        h1, h2, h3 {
            color: #333;
        }
        
        pre {
            background: #f5f5f5;
            padding: 10px;
            overflow: auto;
            max-height: 200px;
            border-radius: 4px;
        }
        
        .belief-distribution {
            margin-top: 10px;
            margin-bottom: 20px;
        }
        
        .belief-bar {
            height: 20px;
            display: flex;
            margin-bottom: 5px;
        }
        
        .belief-segment {
            height: 100%;
            display: inline-block;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
        }
    </style>
</head>
<body>
    <h1>Experiment Tree Visualization</h1>
    
    <div class="upload-area" id="upload-area">
        <p>Drop node log files here or click to upload</p>
        <input type="file" id="file-upload" multiple style="display: none">
        <div class="file-list" id="file-list"></div>
    </div>
    
    <div class="container">
        <div id="tree-container"></div>
        <div id="details-panel">
            <h2>Node Details</h2>
            <p>Click on a node to view details</p>
        </div>
    </div>
    
    <script>
        // Global variables to store node data
        let nodeData = {};
        let treeData = null;
        
        // Initialize the upload area
        const uploadArea = document.getElementById('upload-area');
        const fileUpload = document.getElementById('file-upload');
        const fileList = document.getElementById('file-list');
        
        uploadArea.addEventListener('click', () => fileUpload.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.background = '#f0f0f0';
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.background = 'none';
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.background = 'none';
            
            if (e.dataTransfer.files.length > 0) {
                handleFiles(e.dataTransfer.files);
            }
        });
        
        fileUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(e.target.files);
            }
        });
        
        function handleFiles(files) {
            // Clear previous files
            fileList.innerHTML = '';
            nodeData = {};
            
            let filesProcessed = 0;
            
            Array.from(files).forEach(file => {
                if (file.name.match(/node_\d+_\d+\.log/)) {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = file.name;
                    fileList.appendChild(fileItem);
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        parseNodeLog(file.name, content);
                        
                        filesProcessed++;
                        if (filesProcessed === files.length) {
                            buildTree();
                        }
                    };
                    reader.readAsText(file);
                } else {
                    console.warn(`Skipping file ${file.name} - not a node log file`);
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        buildTree();
                    }
                }
            });
        }
        
        function parseNodeLog(filename, content) {
            // Extract level and node index from filename
            const match = filename.match(/node_(\d+)_(\d+)\.log/);
            if (!match) return;
            
            const level = parseInt(match[1]);
            const nodeIndex = parseInt(match[2]);
            
            try {
                // Try to parse the content as JSON if it's properly formatted
                let logMessages;
                try {
                    const jsonContent = content.trim();
                    // Check if the content is a JSON array
                    if (jsonContent.startsWith('[') && jsonContent.endsWith(']')) {
                        logMessages = JSON.parse(jsonContent);
                    } else {
                        // If not a proper JSON array, try to extract messages
                        const messages = [];
                        const lines = content.split('\n');
                        let jsonStr = '';
                        for (const line of lines) {
                            if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                                try {
                                    const msg = JSON.parse(line.trim());
                                    messages.push(msg);
                                } catch (e) {
                                    // Skip invalid JSON lines
                                }
                            } else if (line.trim()) {
                                jsonStr += line;
                                if (jsonStr.includes('}')) {
                                    try {
                                        const closingIndex = jsonStr.lastIndexOf('}') + 1;
                                        const msgStr = jsonStr.substring(0, closingIndex);
                                        const msg = JSON.parse(msgStr);
                                        messages.push(msg);
                                        jsonStr = jsonStr.substring(closingIndex);
                                    } catch (e) {
                                        // Continue building the JSON string
                                    }
                                }
                            }
                        }
                        logMessages = messages;
                    }
                } catch (e) {
                    console.error("Error parsing log content:", e);
                    
                    // Fallback: try to parse each line as a separate JSON object
                    logMessages = [];
                    const lines = content.split('\n');
                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                const message = JSON.parse(line.trim());
                                logMessages.push(message);
                            } catch (e) {
                                // Skip lines that can't be parsed as JSON
                            }
                        }
                    }
                }
                
                // Process the log messages for this node
                const nodeInfo = processNodeMessages(logMessages);
                
                // Store the processed node data
                if (!nodeData[level]) {
                    nodeData[level] = {};
                }
                nodeData[level][nodeIndex] = nodeInfo;
            } catch (e) {
                console.error(`Error processing ${filename}:`, e);
            }
        }
        
        function processNodeMessages(messages) {
            let experiment = null;
            let hypothesis = null;
            let analysis = null;
            let supportsHypothesis = null;
            let priorBelief = null;
            let posteriorBelief = null;
            
            // Find the last user_proxy message (the experiment)
            let lastUserProxyIndex = -1;
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg?.name === 'user_proxy' && msg?.role === 'user') {
                    experiment = msg.content;
                    lastUserProxyIndex = i;
                    break;
                }
            }
            
            // Only process messages after the last user_proxy message
            if (lastUserProxyIndex >= 0) {
                // Find the hypothesis, analysis, support status, and belief distributions
                let foundHypothesis = false;
                let foundReview = false;
                
                for (let i = lastUserProxyIndex + 1; i < messages.length; i++) {
                    const msg = messages[i];
                    
                    if (msg?.name === 'hypothesis_generator' && msg?.role === 'user') {
                        try {
                            const hypData = JSON.parse(msg.content);
                            hypothesis = hypData.hypothesis;
                        } catch (e) {
                            hypothesis = msg.content;
                        }
                        foundHypothesis = true;
                    } else if (msg?.name === 'experiment_analyst' && msg?.role === 'user') {
                        try {
                            const analysisData = JSON.parse(msg.content);
                            analysis = analysisData.analysis;
                        } catch (e) {
                            analysis = msg.content;
                        }
                    } else if (msg?.name === 'experiment_reviewer' && msg?.role === 'user') {
                        try {
                            const reviewData = JSON.parse(msg.content);
                            supportsHypothesis = reviewData.supports_hypothesis;
                        } catch (e) {
                            // Cannot determine if hypothesis is supported
                        }
                        foundReview = true;
                    } else if (msg?.name === 'belief_distribution_agent' && msg?.role === 'user') {
                        try {
                            const beliefData = JSON.parse(msg.content);
                            
                            // Check if this is prior or posterior belief based on timing
                            if (foundHypothesis && !foundReview) {
                                // This is prior belief (after hypothesis generation)
                                priorBelief = beliefData;
                            } else if (foundReview) {
                                // This is posterior belief (after experiment review)
                                posteriorBelief = beliefData;
                            }
                        } catch (e) {
                            console.error("Error parsing belief distribution:", e);
                        }
                    }
                }
            }
            
            return { 
                experiment, 
                hypothesis, 
                analysis, 
                supportsHypothesis,
                priorBelief,
                posteriorBelief
            };
        }
        
        function buildTree() {
            // Create tree hierarchy from node data
            const levels = Object.keys(nodeData).map(Number).sort((a, b) => a - b);
            if (levels.length === 0) return;
            
            // Start with the root node (level 0)
            if (!nodeData[0] || !nodeData[0][0]) {
                console.error("Root node (0,0) not found");
                return;
            }
            
            const root = {
                id: "0_0",
                level: 0,
                index: 0,
                data: nodeData[0][0],
                children: []
            };
            
            // Determine the branching factor based on the number of children of the root
            let branchingFactor = 0;
            if (nodeData[1]) {
                branchingFactor = Object.keys(nodeData[1]).length;
            }
            
            // Recursively build the tree
            function addChildren(node, level) {
                if (!nodeData[level]) return;
                
                const indices = Object.keys(nodeData[level]).map(Number).sort((a, b) => a - b);
                for (const idx of indices) {
                    // Calculate parent index based on branching factor
                    const parentIndex = Math.floor(idx / branchingFactor);
                    
                    // Only add this node as a child if its parent matches the current node
                    if (node.level === level - 1 && node.index === parentIndex) {
                        const childId = `${level}_${idx}`;
                        const childNode = {
                            id: childId,
                            level: level,
                            index: idx,
                            data: nodeData[level][idx],
                            children: []
                        };
                        
                        node.children.push(childNode);
                        addChildren(childNode, level + 1);
                    }
                }
            }
            
            // Add all children starting from level 1
            for (let i = 1; i < levels.length; i++) {
                const level = levels[i];
                const indices = Object.keys(nodeData[level]).map(Number).sort((a, b) => a - b);
                
                // For each node at this level
                for (const idx of indices) {
                    // Find its parent
                    const parentLevel = level - 1;
                    const parentIndex = Math.floor(idx / branchingFactor);
                    
                    // Find the parent node in our tree
                    function findParent(node) {
                        if (node.level === parentLevel && node.index === parentIndex) {
                            return node;
                        }
                        
                        for (const child of node.children) {
                            const found = findParent(child);
                            if (found) return found;
                        }
                        
                        return null;
                    }
                    
                    const parentNode = findParent(root);
                    if (parentNode) {
                        const childId = `${level}_${idx}`;
                        const childNode = {
                            id: childId,
                            level: level,
                            index: idx,
                            data: nodeData[level][idx],
                            children: []
                        };
                        
                        parentNode.children.push(childNode);
                    }
                }
            }
            
            treeData = root;
            renderTree();
        }
        
        function renderTree() {
            if (!treeData) return;
            
            // Clear previous tree
            d3.select("#tree-container").selectAll("*").remove();
            
            // Set up the D3 tree layout
            const width = document.getElementById('tree-container').offsetWidth;
            const height = document.getElementById('tree-container').offsetHeight;
            
            const margin = { top: 40, right: 90, bottom: 50, left: 90 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create the SVG container
            const svg = d3.select("#tree-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Create the tree layout
            const treeLayout = d3.tree().size([innerHeight, innerWidth]);
            
            // Convert our custom tree structure to D3 hierarchy
            const root = d3.hierarchy(treeData);
            
            // Assign the x and y coordinates to nodes
            const tree = treeLayout(root);
            
            // Draw links between nodes
            svg.selectAll(".link")
                .data(tree.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)  // Swap x and y for horizontal tree
                    .y(d => d.x));
            
            // Create node groups
            const node = svg.selectAll(".node")
                .data(tree.descendants())
                .enter()
                .append("g")
                .attr("class", d => `node node-${d.data.id}`)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .on("click", (event, d) => showNodeDetails(d.data));
            
            // Add circles to nodes
            node.append("circle")
                .attr("r", 8)
                .style("fill", d => d.data.data.supportsHypothesis === true ? "#4CAF50" : 
                                   d.data.data.supportsHypothesis === false ? "#F44336" : 
                                   "#2196F3");
            
            // Add text labels to nodes
            node.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d.children ? -12 : 12)
                .attr("text-anchor", d => d.children ? "end" : "start")
                .text(d => `Node ${d.data.level}_${d.data.index}`);
        }
        
        function showNodeDetails(node) {
            // Clear previous selection
            d3.selectAll(".node").classed("selected", false);
            
            // Highlight selected node
            d3.select(`.node.node-${node.id}`).classed("selected", true);
            
            const detailsPanel = document.getElementById('details-panel');
            const data = node.data;
            
            // Format the details HTML
            let html = `<h2>Node ${node.level}_${node.index} Details</h2>`;
            
            if (data.experiment) {
                html += `<h3>Experiment</h3><pre>${data.experiment}</pre>`;
            }
            
            if (data.hypothesis) {
                html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
            }
            
            // Add prior belief distribution if available
            if (data.priorBelief) {
                html += `<h3>Prior Belief Distribution (After Hypothesis Generation)</h3>`;
                html += renderBeliefDistribution(data.priorBelief);
            }
            
            if (data.analysis) {
                html += `<h3>Analysis</h3><pre>${data.analysis}</pre>`;
            }
            
            if (data.supportsHypothesis !== null) {
                const supportText = data.supportsHypothesis ? 
                    "<span style='color: green'>YES</span>" : 
                    "<span style='color: red'>NO</span>";
                html += `<h3>Supports Hypothesis</h3><p>${supportText}</p>`;
            }
            
            // Add posterior belief distribution if available
            if (data.posteriorBelief) {
                html += `<h3>Posterior Belief Distribution (After Experiment Review)</h3>`;
                html += renderBeliefDistribution(data.posteriorBelief);
            }
            
            detailsPanel.innerHTML = html;
        }
        
        function renderBeliefDistribution(beliefData) {
            let html = '<div class="belief-distribution">';
            
            // Check if we have a distribution object
            if (beliefData.distribution) {
                const distribution = beliefData.distribution;
                const colors = ['#4CAF50', '#FFC107', '#F44336', '#2196F3', '#9C27B0', '#FF5722'];
                
                // Create a bar visualization
                html += '<div class="belief-bar">';
                
                let totalWidth = 0;
                let index = 0;
                
                for (const [hypothesis, probability] of Object.entries(distribution)) {
                    const width = probability * 100;
                    const color = colors[index % colors.length];
                    
                    html += `<div class="belief-segment" style="width: ${width}%; background-color: ${color};" 
                                title="${hypothesis}: ${(probability * 100).toFixed(1)}%">
                                ${(probability * 100).toFixed(0)}%
                            </div>`;
                    
                    totalWidth += width;
                    index++;
                }
                
                html += '</div>';
                
                // Add a legend
                html += '<div class="belief-legend">';
                index = 0;
                for (const [hypothesis, probability] of Object.entries(distribution)) {
                    const color = colors[index % colors.length];
                    html += `<div style="margin-bottom: 5px;">
                                <span style="display: inline-block; width: 12px; height: 12px; background-color: ${color}; margin-right: 5px;"></span>
                                ${hypothesis}: ${(probability * 100).toFixed(1)}%
                            </div>`;
                    index++;
                }
                html += '</div>';
            } else if (beliefData.beliefs) {
                // Alternative format
                html += '<pre>' + JSON.stringify(beliefData.beliefs, null, 2) + '</pre>';
            } else {
                // Raw format
                html += '<pre>' + JSON.stringify(beliefData, null, 2) + '</pre>';
            }
            
            html += '</div>';
            return html;
        }
    </script>
</body>
</html>
